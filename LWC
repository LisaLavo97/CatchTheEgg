open System.Windows.Forms
open System.Drawing
open System.Drawing.Drawing2D

type MyButton() as this =
    inherit UserControls()

    let mutable controlled = ResizeArray<LWC>()
    let timer = new Timer(Interval = 100)

    do
        timer.Tick.Add(fun _-> this.Update())
    done
    
    member this.Controlled with get() = controlled

    member this.Update () =
        for i in 0 .. controlled.Count-1 do
            controlled.[i].NTranslate 0.f 10.f
            controlled.[i].Invalidate()
        

    override this.OnMouseDown e =
        timer.Start()
    
    override this.OnMouseUp e =
        timer.Stop()

    override this.OnResize e =
        this.Invalidate()
    
    override this.OnPaint e =
        let g = e.Graphics
        let brushes = Brushes.Gold
        g.fillRectangle(brushes, 0.f, 0.f, 25.f, 25.f)

type LWC() as this =
    inherit UserControls()

    // a 'points' associo una lista di punti
    let mutable points = ResizeArray<PointF>()

    // inizialmente None, dopo non prende un bool ma un Punto
    let mutable drag = None

    // matrice diagonale che identifica tutto il piano
    let mutable world = new Drawing2D.Matrix()
    let mutable view = new Drawing2D.Matrix()

    // funzione per controllare che un click non sia all'interno di una delle maniglie
    // prende in input un punto e una coppia di coordiante
    let isInHandle() (p: PointF) (x:float32) (y:float32) : bool =
        let quad v = v*v
        let x1 = x - p.X, y1 = y - p.Y
        // la somma dei quadrati è minore del raggio?
        quad x1 + quad y1 <= quad 5.f

    //inizializzazione
    do 
        points.Add(PointF(0.f, 0.f))
         points.Add(PointF(50.f, 50.f))
        /* Se true, il disegno viene eseguito in un buffer e, una volta completato, 
         il risultato viene inviato allo schermo. Il doppio buffer impedisce lo sfarfallio causato dal ridisegno del controllo. 
         Se si imposta DoubleBuffer su true, è necessario impostare anche UserPaint e AllPaintingInWmPaint su true. */
        this.SetStyle(ControlStyles.DoubleBuffer, true)
        // quando questa proprietà è a true il controllo ignora il messaggio finestra WM_ERASEBKGND per ridurre lo sfarfallio
        this.SetStyle(ControlStyles.AllPaintingInWmPaint, true)
    done

    // ogni volta che la chiamo sposto il mondo 
    member this.NTranslate (x:float32) (y:float32) =
        do  
            // per tornare indietro devo fare le stesse mosse ma al contrario, quindi anche in ordine inverso
            world.Translate(x, y, MatrixOrder.Append)
            view.Translate(-x, -y, MatrixOrder.Prepend)
        done
    
    member this.NRotate (a:float32) =
        do  
            world.Rotate(a, MatrixOrder.Append)
            view.Rotate(-a, MatrixOrder.Prepend)
        done
        
    // così ridimensionando la finestra viene ridisegnato tutto
    override this.OnResize e =
        this.Invalidate()

    override this.OnPaint e =
        // prendo il contesto grafico in modo da poterci disegnare
        let g = e.Graphics
        // per rendere le linee più carine
        g.SmoothingMode <- System.Drawing.Drawing2D.SmoothingMode.AntiAlias
        // devo dire al contesto grafico che devo disegnare il mondo traslato 
        g.Transform <- world
        g.DrawLines(Pens.Black, points.ToArray())
        // Disegno le "maniglie" da cui tirare i punti
        // per ogni punto nell'array
        for i in 0 .. (points.Count-1) do
            // prendo quel punto
            let punto = points.[i]
            // prendo il rettangolo intorno ad esso (guarda dims)
            let r = RectangleF(PointF(punto.X-5.f, punto.Y-5.f),SizeF(10.f, 10.f))
            // disegno un cerchio dentro a questo rettangolo
            g.DrawEllipse(Pens.Red, r)
    
    override this.OnMouseDown e = 
        // prendo in p il punto dove ho cliccato (single identifica interi)
        let mutable p = [|PointF((single)e.X, (single)e.Y)|]
        // trasformo il punto dove ho cliccato in un punto MONDO, per ora è solo un punto VISTA
        view.TransformPoints p 
        // controllo se il punto cliccato appartiene ad una delle manigle
        match(points |> Array.tryFindIndex (fun punto -> isInHandle punto p.[0].X p.[0].Y)) with
            // se si non lo aggiungo
            | Some index -> do
                drag <- do
                    drag <- Some index

            // altrimenti lo aggiungo
            | _ -> do 
                // aggiungo il punto dell'ultimo click all'array dei punti che vengono disegnati
                points.Add(p.[0])
                this.Invalidate()

    override this.OnMouseUp e =
        drag <- None

    override this.OnMouseMove e = 
    match drag with 
        | Some index -> do
                // prima di aggiornare la nuova posizione del punto devo trasformarlo da VISTA a MONDO
                let mutable p = [|PointF((single)e.X, (single)e.Y)|]
                view.TransformPoints p 
                points.[index] <- p.[0]
                this.Invalidate() done
        | _ -> ()

    override this.OnKeyDown e = 
        match e.KeyCode with
            | Keys.W -> this.NTranslate 0.f, -10.f
            | Keys.E -> this.NRotate 10.f
            | _ -> ()
            this.Invalidate()
    
let f = new Form(Text = "titolo")
f.Show()

let but = new MyButton()
but.Size <- Size(25,25)
f.Controls.Add(but)

// mettilo su tutta la mia finestra
let lwc = new LWC(Dock = DockStyle.Fill)
// aggiungo il controllo ai controlli della finestra
f.Controls.Add(lwc)
// perchè prenda gli input da tastiera
lwc.Select()

but.Controlled.Add(lwc)


